using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using JetBrains.Annotations;
using PrimeTween;
using Sirenix.OdinInspector;
using UnityEditor;
using UnityEngine;
using Assert = UnityEngine.Assertions.Assert;

internal class CodeGenerator : SerializedScriptableObject
{
    [SerializeField]
    MonoScript methodsScript;

    [SerializeField]
    MonoScript dotweenMethodsScript;

    [SerializeField]
    MonoScript editorUtilsScript;

    [SerializeField]
    MonoScript tweenAnimationScript;

    [SerializeField]
    Dictionary<string, MethodDatas> methodsDataDic;

    [HideReferenceObjectPicker]
    private class MethodDatas
    {
        [ListDrawerSettings(ShowIndexLabels = true, ListElementLabelName = "methodName", AddCopiesLastElement = true)]
        public List<MethodGenerationData> Datas = new List<MethodGenerationData>();
    }

    [ContextMenu(nameof(generateAllMethods))]
    internal void generateAllMethods()
    {
        GenerateMethods();
        GenerateDotweenMethods();
        GenerateTweenAnimation();
    }

    const string generatorBeginLabel = "// CODE GENERATOR BEGIN";
    const string generatorEndLabel = "// CODE GENERATOR END";

    const string textMeshProScriptingDefine =
        "#if TEXT_MESH_PRO_INSTALLED || (UNITY_6000_0_OR_NEWER && UNITY_UGUI_INSTALLED)";

    static void SaveScript(MonoScript script, string text)
    {
        var path = AssetDatabase.GetAssetPath(script);
        if (text == File.ReadAllText(path))
        {
            return;
        }

        File.WriteAllText(path, text);
        EditorUtility.SetDirty(script);
        AssetDatabase.Refresh();
        AssetDatabase.SaveAssets();
    }

    void GenerateDotweenMethods()
    {
        // todo combine adapter files into one file
        var str = @"
// This file is generated by CodeGenerator.cs
using JetBrains.Annotations;
using System;

namespace PrimeTween {
    [PublicAPI]
    public static partial class DOTweenAdapter {";
        const string dotweenOverload =
            "        public static Tween DOTWEEN_METHOD_NAME([NotNull] this UnityEngine.Camera target, Single endValue, float duration) => Tween.METHOD_NAME(target, new TweenSettings<float>(endValue: endValue, duration: duration));";
        str += GenerateWithDefines(data =>
        {
            if (!data.dotweenMethodName.Any())
            {
                return string.Empty;
            }

            Assert.IsTrue(data.dotweenMethodName.Any());
            string result = "";
            result += "\n";
            result += PopulateTemplate(dotweenOverload.Replace("DOTWEEN_METHOD_NAME", data.dotweenMethodName), data);
            return result;
        });
        str += @"
    }
}
";
        SaveScript(dotweenMethodsScript, str);
    }

    void GenerateTweenAnimation()
    {
        StringBuilder sb = new StringBuilder();
        foreach (var group in methodsDataDic.Values.SelectMany(x => x.Datas).ToArray().GroupBy(x => x.dependency))
        {
            var dependency = group.Key;
            if (ShouldWrapInDefine(dependency))
            {
                switch (dependency)
                {
                    case Dependency.PRIME_TWEEN_EXPERIMENTAL:
                    case Dependency.UI_ELEMENTS_MODULE_INSTALLED:
                        sb.Append($"#if {dependency}\n");
                        break;
                    case Dependency.TEXT_MESH_PRO_INSTALLED:
                        sb.Append($"{textMeshProScriptingDefine}\n");
                        break;
                    default:
                        sb.Append($"#if !UNITY_2019_1_OR_NEWER || {dependency}\n");
                        break;
                }
            }

            foreach (var data in group)
            {
                sb.AppendLine();
                sb.AppendLine($"            case TweenType.{data.TweenTypeEnumName}:");
                sb.AppendLine($"                Tween.{data.MethodName}(TargetObject as {data.TargetType.FullName},\n" +
                              $"                    StartEndVal.startFromCurrent\n" +
                              $"                        ? new TweenSettings<{data.propertyType.ToFullTypeName()}>(StartEndVal.endValue.{ValueContainer.GetValNameFromPropType(data.propertyType)}, TweenSettings)\n" +
                              $"                        : new TweenSettings<{data.propertyType.ToFullTypeName()}>(StartEndVal.startValue.{ValueContainer.GetValNameFromPropType(data.propertyType)}, StartEndVal.endValue.{ValueContainer.GetValNameFromPropType(data.propertyType)},\n" +
                              $"                            TweenSettings));");
                sb.AppendLine("                break;");
            }

            if (ShouldWrapInDefine(dependency))
            {
                sb.Append("#endif\n");
            }
        }

        var content = tweenAnimationScript.text;
        content = Regex.Replace(content, @$"{generatorBeginLabel}[\w\W]*?{generatorEndLabel}",
            $"{generatorBeginLabel}{sb}{generatorEndLabel}");
        SaveScript(tweenAnimationScript, content);
    }

    static bool ShouldWrapInDefine(Dependency d)
    {
        switch (d)
        {
            case Dependency.UNITY_UGUI_INSTALLED:
            case Dependency.AUDIO_MODULE_INSTALLED:
            case Dependency.PHYSICS_MODULE_INSTALLED:
            case Dependency.PHYSICS2D_MODULE_INSTALLED:
            case Dependency.PRIME_TWEEN_EXPERIMENTAL:
            case Dependency.UI_ELEMENTS_MODULE_INSTALLED:
            case Dependency.TEXT_MESH_PRO_INSTALLED:
                return true;
        }

        return false;
    }

    // const string overloadTemplateTo = @"        public static Tween METHOD_NAME([NotNull] UnityEngine.Camera target, Single endValue, float duration, Ease ease = Ease.Default, int cycles = 1, CycleMode cycleMode = CycleMode.Restart, float startDelay = 0, float endDelay = 0, bool useUnscaledTime = false) 
    //         => METHOD_NAME(target, new TweenSettings<float>(target.orthographicSize, endValue, new TweenSettings(duration, ease, cycles, cycleMode, startDelay, endDelay, useUnscaledTime)));
    //     public static Tween METHOD_NAME([NotNull] UnityEngine.Camera target, Single endValue, TweenSettings settings) => METHOD_NAME(target, new TweenSettings<float>(endValue, settings));";
    const string fullTemplate =
        @"        public static Tween METHOD_NAME([NotNull] UnityEngine.Camera target, TweenSettings<float> settings) {
            return animate(target, ref settings, _tween => {
                var _target = _tween.target as UnityEngine.Camera;
                var val = _tween.FloatVal;
                _target.orthographicSize = val;
            }, t => (t.target as UnityEngine.Camera).orthographicSize.ToContainer(), TweenType.CameraOrthographicSize);
        }";

    void GenerateMethods()
    {
        var searchIndex = methodsScript.text.IndexOf(generatorBeginLabel, StringComparison.Ordinal);
        Assert.AreNotEqual(-1, searchIndex);
        var text = new StringBuilder(methodsScript.text.Substring(0, searchIndex + generatorBeginLabel.Length) + "\n");

        var methodDataToEnumName = new Dictionary<MethodGenerationData, string>();
        // generate enums
        foreach (var group in methodsDataDic.Values.SelectMany(x => x.Datas).ToArray().GroupBy(d => d.dependency))
        {
            foreach (var data in group)
            {
                text.Append("        ");
                var enumName = data.TweenTypeEnumName;
                text.Append(enumName);
                text.Append(",\n");
            }
        }

        text.Append("    }\n\n");
        text.Append("    public partial struct Tween {");
        text.Append(GenerateWithDefines(Generate));
        AddCustomAnimationMethods(text);
        text.Append(@"
    }
}");
        SaveScript(methodsScript, text.ToString());
        GenerateUtilsScript();
    }

    private void GenerateUtilsScript()
    {
        // generate TweenTypeToTweenData()
        // todo combine Utils class with TweenGenerated or Extensions file
        string utilsText = @"using System;
using PrimeTween;

internal static class Utils {
    internal static (PropType, Type) TweenTypeToTweenData(TweenType tweenType) {
        switch (tweenType) {
";
        foreach (var group in methodsDataDic.Values.SelectMany(x => x.Datas).ToArray().GroupBy(x => x.dependency))
        {
            var dependency = group.Key;
            if (ShouldWrapInDefine(dependency))
            {
                switch (dependency)
                {
                    case Dependency.PRIME_TWEEN_EXPERIMENTAL:
                    case Dependency.UI_ELEMENTS_MODULE_INSTALLED:
                        utilsText += $"            #if {dependency}\n";
                        break;
                    case Dependency.TEXT_MESH_PRO_INSTALLED:
                        utilsText += $"            {textMeshProScriptingDefine}\n";
                        break;
                    default:
                        utilsText += $"            #if !UNITY_2019_1_OR_NEWER || {dependency}\n";
                        break;
                }
            }

            foreach (var data in group)
            {
                utilsText += $"            case TweenType.{data.TweenTypeEnumName}:\n";
                utilsText +=
                    $"                return (PropType.{data.propertyType}, typeof({data.TargetType.FullName}));\n";
            }

            if (ShouldWrapInDefine(dependency))
            {
                utilsText += "            #endif\n";
            }
        }

        var tweenTypeData = new List<(TweenType, PropType, Type)>
        {
            (TweenType.None, PropType.None, null),
            (TweenType.Delay, PropType.Float, null),
            (TweenType.Callback, PropType.Float, null),
            (TweenType.ShakeLocalPosition, PropType.Vector3, typeof(Transform)),
            (TweenType.ShakeLocalRotation, PropType.Quaternion, typeof(Transform)),
            (TweenType.ShakeScale, PropType.Vector3, typeof(Transform)),
            (TweenType.ShakeCustom, PropType.Vector3, typeof(Transform)),
            (TweenType.CustomFloat, PropType.Float, null),
            (TweenType.CustomColor, PropType.Color, null),
            (TweenType.CustomVector2, PropType.Vector2, null),
            (TweenType.CustomVector3, PropType.Vector3, null),
            (TweenType.CustomVector4, PropType.Vector4, null),
            (TweenType.CustomQuaternion, PropType.Quaternion, null),
            (TweenType.CustomRect, PropType.Rect, null),
            (TweenType.CustomDouble, PropType.Double, null),
            (TweenType.MaterialColorProperty, PropType.Color, typeof(Material)),
            (TweenType.MaterialProperty, PropType.Float, typeof(Material)),
            (TweenType.MaterialAlphaProperty, PropType.Float, typeof(Material)),
            (TweenType.MaterialTextureOffset, PropType.Vector2, typeof(Material)),
            (TweenType.MaterialTextureScale, PropType.Vector2, typeof(Material)),
            (TweenType.MaterialPropertyVector4, PropType.Vector4, typeof(Material)),
            (TweenType.LocalEulerAngles, PropType.Vector3, typeof(Transform)),
            (TweenType.EulerAngles, PropType.Vector3, typeof(Transform)),
            (TweenType.GlobalTimeScale, PropType.Float, null),
            (TweenType.MainSequence, PropType.Float, null),
            (TweenType.NestedSequence, PropType.Float, null)
        };
        foreach (var tuple in tweenTypeData)
        {
            utilsText += $"            case TweenType.{tuple.Item1}:\n";
            string typeStr = tuple.Item3 == null ? "null" : $"typeof({tuple.Item3})";
            utilsText += $"                return (PropType.{tuple.Item2}, {typeStr});\n";
        }

        utilsText += @"            default:
                return (PropType.None, null);
        }
    }
}
";
        SaveScript(editorUtilsScript, utilsText);
    }

    [NotNull]
    string GenerateWithDefines([NotNull] Func<MethodGenerationData, string> generator)
    {
        string result = "";
        foreach (var group in methodsDataDic.Values.SelectMany(x => x.Datas).ToArray().GroupBy(d => d.dependency))
        {
            result += DoGenerateWithDefines(generator, group);
        }

        return result;
    }

    [NotNull]
    static string DoGenerateWithDefines([NotNull] Func<MethodGenerationData, string> generator,
        [NotNull] IGrouping<Dependency, MethodGenerationData> group)
    {
        var result = "";
        var dependency = group.Key;
        if (ShouldWrapInDefine(dependency))
        {
            switch (dependency)
            {
                case Dependency.PRIME_TWEEN_EXPERIMENTAL:
                case Dependency.UI_ELEMENTS_MODULE_INSTALLED:
                    result += $"\n        #if {dependency}";
                    break;
                case Dependency.TEXT_MESH_PRO_INSTALLED:
                    result += $"\n        {textMeshProScriptingDefine}";
                    break;
                default:
                    result += $"\n        #if !UNITY_2019_1_OR_NEWER || {dependency}";
                    break;
            }
        }

        foreach (var method in group)
        {
            var generated = generator(method);
            if (!string.IsNullOrEmpty(generated))
            {
                result += generated;
                result += "\n";
            }
        }

        if (ShouldWrapInDefine(dependency))
        {
            result += "\n        #endif";
        }

        return result;
    }

    [NotNull]
    static string Generate([NotNull] MethodGenerationData data)
    {
        var methodName = data.MethodName;
        Assert.IsTrue(System.CodeDom.Compiler.CodeGenerator.IsValidLanguageIndependentIdentifier(methodName),
            $"Method name is invalid: {methodName}.");
        var propertyName = data.propertyName;

        // var overload = populateTemplate(overloadTemplateTo, data);
        string overload = "";
        var full = PopulateTemplate(fullTemplate, data);
        const string templatePropName = "orthographicSize";
        string replaced = "";
        if (data.generateOnlyOverloads)
        {
            replaced += "\n";
            replaced += overload;

            replaced = replaced.Replace(templatePropName, propertyName);
        }
        else if (propertyName.Any())
        {
            checkFieldOrProp();
            Assert.IsTrue(string.IsNullOrEmpty(data.propertyGetter));
            Assert.IsTrue(string.IsNullOrEmpty(data.propertyGetter));
            replaced += "\n";
            replaced += overload;
            replaced += "\n";
            replaced += full;
            replaced = replaced.Replace(templatePropName, propertyName);

            void checkFieldOrProp()
            {
                var type = data.TargetType;
                Assert.IsNotNull(type);
                const BindingFlags flags = BindingFlags.Instance | BindingFlags.Public;
                var prop = type.GetProperty(propertyName, flags);
                Type expectedPropType;
                if (data.propertyType == PropType.Float)
                {
                    expectedPropType = typeof(float);
                }
                else if (data.propertyType == PropType.Int)
                {
                    expectedPropType = typeof(int);
                }
                else
                {
                    var typeName = $"{data.propertyType.ToFullTypeName()}, UnityEngine.CoreModule";
                    expectedPropType = Type.GetType(typeName);
                    Assert.IsNotNull(expectedPropType, typeName);
                }

                if (prop != null)
                {
                    Assert.AreEqual(expectedPropType, prop.PropertyType);
                    return;
                }

                var field = type.GetField(propertyName, flags);
                if (field != null)
                {
                    Assert.AreEqual(expectedPropType, field.FieldType, "Field type is incorrect.");
                    return;
                }

                throw new Exception(
                    $"Field or property with name ({propertyName}) not found for type {type.FullName}. Generation data name: {data.description}.");
            }
        }
        else
        {
            Assert.IsTrue(data.propertySetter.Any());
            if (data.propertyGetter.Any())
            {
                replaced += "\n";
                replaced += replaceGetter(overload);
            }

            replaced += "\n";
            full = replaceSetter(full);
            replaced += replaceGetter(full);

            // ReSharper disable once AnnotateNotNullTypeMember
            string replaceGetter(string str)
            {
                while (true)
                {
                    var j = str.IndexOf(templatePropName, StringComparison.Ordinal);
                    if (j == -1)
                    {
                        break;
                    }

                    Assert.AreNotEqual(-1, j);
                    str = str.Remove(j, templatePropName.Length);
                    str = str.Insert(j, data.propertyGetter);
                }

                return str;
            }

            // ReSharper disable once AnnotateNotNullTypeMember
            string replaceSetter(string str)
            {
                while (true)
                {
                    var k = str.IndexOf("orthographicSize =", StringComparison.Ordinal);
                    if (k == -1)
                    {
                        break;
                    }

                    Assert.AreNotEqual(-1, k);
                    var endIndex = str.IndexOf(";", k, StringComparison.Ordinal);
                    Assert.AreNotEqual(-1, endIndex);
                    str = str.Remove(k, endIndex - k);
                    str = str.Insert(k, data.propertySetter);
                }

                return str;
            }
        }

        return replaced;
    }

    static void AddCustomAnimationMethods(StringBuilder text)
    {
        const string template =
            @"public static Tween Custom_TEMPLATE(TweenSettings<float> settings, [NotNull] Action<Single> onValueChange) {
            Assert.IsNotNull(onValueChange);
            if (settings.startFromCurrent) {
                UnityEngine.Debug.LogWarning(Constants.customTweensDontSupportStartFromCurrentWarning);
            }
            var tween = PrimeTweenManager.fetchTween();
            tween.startValue.CopyFrom(ref settings.startValue);
            tween.endValue.CopyFrom(ref settings.endValue);
            tween.setPropType(PropType.Float);
            tween.customOnValueChange = onValueChange;
            tween.Setup(PrimeTweenManager.dummyTarget, ref settings.settings, _tween => {
                var _onValueChange = _tween.customOnValueChange as Action<Single>;
                var val = _tween.FloatVal;
                try {
                    _onValueChange(val);
                } catch (Exception e) {
                    Assert.LogError($""Tween was stopped because of exception in {nameof(onValueChange)} callback, tween: {_tween.GetDescription()}, exception:\n{e}\n"", _tween.id, _tween.target as UnityEngine.Object);
                    _tween.EmergencyStop();
                }
            }, null, false, TweenType.CustomFloat);
            return PrimeTweenManager.Animate(tween);
        }
        public static Tween Custom_TEMPLATE<T>([NotNull] T target, TweenSettings<float> settings, [NotNull] Action<T, Single> onValueChange) where T : class 
            => Custom_internal(target, settings, onValueChange);
        static Tween Custom_internal<T>([NotNull] T target, TweenSettings<float> settings, [NotNull] Action<T, Single> onValueChange, bool isAdditive = false) where T : class {
            Assert.IsNotNull(onValueChange);
            if (settings.startFromCurrent) {
                UnityEngine.Debug.LogWarning(Constants.customTweensDontSupportStartFromCurrentWarning);
            }
            var tween = PrimeTweenManager.fetchTween();
            tween.startValue.CopyFrom(ref settings.startValue);
            tween.endValue.CopyFrom(ref settings.endValue);
            tween.setPropType(PropType.Float);
            tween.customOnValueChange = onValueChange;
            tween.isAdditive = isAdditive;
            tween.Setup(target, ref settings.settings, _tween => {
                var _onValueChange = _tween.customOnValueChange as Action<T, Single>;
                var _target = _tween.target as T;
                Single val;
                if (_tween.isAdditive) {
                    var newVal = _tween.FloatVal;
                    val = newVal.calcDelta(_tween.prevVal);
                    _tween.prevVal.FloatVal = newVal;
                } else {
                    val = _tween.FloatVal;
                }
                try {
                    _onValueChange(_target, val);
                } catch (Exception e) {
                    Assert.LogError($""Tween was stopped because of exception in {nameof(onValueChange)} callback, tween: {_tween.GetDescription()}, exception:\n{e}\n"", _tween.id, _tween.target as UnityEngine.Object);
                    _tween.EmergencyStop();
                }
            }, null, false, TweenType.CustomFloat);
            return PrimeTweenManager.Animate(tween);
        }
   ";

        var types = new[]
        {
            typeof(float), typeof(Color), typeof(Vector2), typeof(Vector3), typeof(Vector4), typeof(Quaternion),
            typeof(Rect)
        };
        foreach (var type in types)
        {
           text.Append("\n\n");
            var isFloat = type == typeof(float);
            var replaced = template;
            replaced = replaced.Replace("Single", isFloat ? "float" : type.FullName);
            if (!isFloat)
            {
                replaced = replaced.Replace("TweenSettings<float>", $"TweenSettings<{type.FullName}>");
                replaced = replaced.Replace(".FloatVal", $".{type.Name}Val");
                replaced = replaced.Replace("Single val;", $"{type.Name} val;");
                replaced = replaced.Replace("PropType.Float", $"PropType.{type.Name}");
                replaced = replaced.Replace("TweenType.CustomFloat", $"TweenType.Custom{type.Name}");
            }

            replaced = replaced.Replace("Custom_TEMPLATE", "Custom");
           text.Append(replaced);
        }
    }

    [NotNull]
    static string PopulateTemplate([NotNull] string str, [NotNull] MethodGenerationData data)
    {
        var methodName = data.MethodName;

        var targetType = data.TargetType.FullName;
        if (string.IsNullOrEmpty(targetType))
        {
            str = str.Replace("[NotNull] UnityEngine.Camera target, ", "")
                .Replace("METHOD_NAME(target, ", "METHOD_NAME(");
        }
        else
        {
            str = str.Replace("UnityEngine.Camera", targetType);
        }

        str = str.Replace("METHOD_NAME", methodName);
        str = str.Replace("TweenType.CameraOrthographicSize", $"TweenType.{data.TweenTypeEnumName}");
        if (data.propertyType != PropType.Float)
        {
            str = str.Replace("Single", data.propertyType.ToFullTypeName());
            str = str.Replace("_tween.FloatVal", $"_tween.{data.propertyType.ToString()}Val");
            str = str.Replace("TweenSettings<float>", $"TweenSettings<{data.propertyType.ToFullTypeName()}>");
        }

        return str;
    }
}

[Serializable]
[HideReferenceObjectPicker]
class MethodGenerationData {
    public string description;
    [SerializeField]
    string methodName;
    [SerializeField]
    string targetType;
    public PropType propertyType;

    public string propertyName;

    public string propertyGetter;
    public string propertySetter;
    public string dotweenMethodName;
    public Dependency dependency;
    public bool generateOnlyOverloads;
    
    [CanBeNull]
    static string GetMethodPrefix(Dependency dep)
    {
        switch (dep)
        {
            case Dependency.UNITY_UGUI_INSTALLED:
                return "UI";
            case Dependency.AUDIO_MODULE_INSTALLED:
                return "Audio";
            case Dependency.PHYSICS_MODULE_INSTALLED:
            case Dependency.PHYSICS2D_MODULE_INSTALLED:
                return nameof(Rigidbody);
            case Dependency.None:
            case Dependency.PRIME_TWEEN_EXPERIMENTAL:
            case Dependency.UI_ELEMENTS_MODULE_INSTALLED:
            case Dependency.TEXT_MESH_PRO_INSTALLED:
                return null;
        }

        return dep.ToString();
    }

    public string MethodName
    {
        get
        {
            var prefix = GetMethodPrefix(dependency);
            if (prefix != null)
            {
                return prefix + methodName;
            }

            return methodName;
        }
    }
    
    public Type TargetType
    {
        get
        {
            var types = AppDomain.CurrentDomain
                .GetAssemblies()
                .Select(_ => _.GetType(targetType))
                .Where(_ => _ != null)
                .Where(_ => _.FullName == targetType)
                .Distinct()
                .ToArray();
            switch (types.Length)
            {
                case 0:
                    throw new Exception($"target type ({targetType}) not found in any of the assemblies.\n" +
                                        "Please specify the full name of the type. For example, instead of 'Transform', use 'UnityEngine.Transform'.\n" +
                                        "Or install the target package in Package Manager.\n");
                case 1:
                    break;
                default:
                    throw new Exception($"More than one type found that match {targetType}. Found:\n"
                                        + string.Join("\n",
                                            types.Select(_ =>
                                                $"{_.AssemblyQualifiedName}\n{_.Assembly.GetName().FullName}")));
            }

            var type = types.Single();
            Assert.IsNotNull(type, $"targetType ({targetType}) wasn't found in any assembly.");
            return type;
        }
    }

    public string TweenTypeEnumName
    {
        get
        {
            string result = "";
            if (dependency == Dependency.UI_ELEMENTS_MODULE_INSTALLED && !MethodName.Contains("VisualElement"))
            {
                result += "VisualElement";
            }

            result += MethodName;
            if ((MethodName.Contains("Alpha") || MethodName.Contains("Color")) &&
                dependency == Dependency.UNITY_UGUI_INSTALLED)
            {
                result += TargetType.Name;
            }
            else if ((MethodName.Contains("Rotation") || MethodName.Contains("LocalRotation")) &&
                     propertyType == PropType.Quaternion)
            {
                result += "Quaternion";
            }
            else if (TargetType.FullName.Contains("PrimeTween.Sequence"))
            {
                result += "Sequence";
            }
            else if (TargetType.FullName.Contains("UnityEngine.Rigidbody2D"))
            {
                result += "2D";
            }

            return result;
        }
    }
}

[PublicAPI]
enum Dependency {
    None,
    UNITY_UGUI_INSTALLED,
    AUDIO_MODULE_INSTALLED,
    PHYSICS_MODULE_INSTALLED,
    PHYSICS2D_MODULE_INSTALLED,
    Camera,
    Material,
    Light,
    PRIME_TWEEN_EXPERIMENTAL,
    UI_ELEMENTS_MODULE_INSTALLED,
    TEXT_MESH_PRO_INSTALLED
}

static class Ext
{
    [NotNull]
    internal static string ToFullTypeName(this PropType type)
    {
        switch (type)
        {
            case PropType.None:
                break;
            case PropType.Float:
                return "float";
            case PropType.Int:
                return "int";
            case PropType.Double:
                return "double";
        }

        return $"UnityEngine.{type}";
    }
}